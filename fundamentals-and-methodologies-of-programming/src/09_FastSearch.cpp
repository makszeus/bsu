//----------------------------------------------------------------------------
// Дихотомический поиск в упорядоченном массиве
//----------------------------------------------------------------------------
#include <iostream>

//----------------------------------------------------------------------------
// Для заданного x найти такое i, что
//         /  a[i], если x принадлежит массиву a
//    x = |
//         \  -1, в противном случае
//----------------------------------------------------------------------------
int RSearchEq(const int * a, const int n, const int x) {
   int li = -1, hi = n - 1;
   //И: a[li] <= x < a[hi+1],  -1 <= li <=hi < n
   while (li != hi) { //int m = (li+hi+1)/2;
      const int m = (li + hi + 1) >> 1;
      if (a[m] <= x) li = m; else hi = m - 1;
   }
   // из (И) и li = hi следует a[li]<=x<a[li+1], т.е. i = li
   return x==a[li] ? li: -1;
}
//----------------------------------------------------------------------------
// Для заданного x найти такое i, -1 <= i < n, что a[i] <= x < a[i+1]
//----------------------------------------------------------------------------
int RSearch(const int * a, const int n, const int x) {
   int li = -1, hi = n - 1;
   //И: a[li] <= x < a[hi+1],  -1 <= li <=hi < n
   while (li != hi) { //int m = (li+hi+1)/2;
      const int m = (li + hi + 1) >> 1;
      if (a[m] <= x) li = m; else hi = m - 1;
   }
   // из (И) и li = hi следует a[li]<=x<a[li+1], т.е. i = li
   return li;
}
// Примечание: если li < 0, то полагаем, что a[li]<=x истинно
//             если hi >= n-1, то полагаем, что x < a[hi+1] истинно
//----------------------------------------------------------------------------
//Обоснование инварианта:
//1. (И) истинно в начале выполнения цикла
//2. Пусть (И) истинно в момент проверки условия  li != hi
//   Покажем, что (И) останется истинным после выполнения шага цикла
//   Пусть a[m] <= x. Тогда новое li есть m и, значит, по-прежнему a[li] <= x.
//   Пусть x < a[m]. Тогда новое hi есть m-1 и очевидно по-прежнему x<a[hi+1]
//3. Докажем, что цикл завершится за конечное число шагов.
//   Для этого достаточно показать, что 0 <= hi-li и разность hi-li уменьша-
//   ется после выполнения шага цикла. Это нетрудно видеть при hi-li > 3,
//   а при hi-li <= 3 убеждаемся в этом непосредственной проверкой.
//----------------------------------------------------------------------------

// Вот другой вариант решения этой задачи
//----------------------------------------------------------------------------
// Найти такое i, -1<=i<n, что a[i]<=x<a[i+1]
//----------------------------------------------------------------------------
int RSearch_1(const int * a, const int n, const int x) {
   int li = 0, hi = n;
   //И: a[li-1]<=x<a[hi], 0 <= li <= hi <= n
   while (li != hi) { //int m = (li+hi+1)/2;
      const int m = (li + hi) >> 1;
      if (a[m] <= x) li = m + 1; else hi = m;
   }
   // из (И) и li = hi следует a[li-1]<=x<a[li], т.е. i = li-1
   return li - 1;
}
// Заметим, что в этом варианте шаг цикла содержит на одну операцию меньше
// (при вычислении m). И хотя после завершения цикла из li вычитается 1 (в
// первом варианте этого нет), в конечном итоге данный вариант эфективнее
// первого
//----------------------------------------------------------------------------

int main() {

    int n = 0;
    std::cout << "Enter n: ";
    std::cin >> n;
    const auto a = new int[n];
    std::cout << "\nEnter array[" << n << "]: " << std::endl;
    for (int i = 0; i<n; ++i)
        std::cin >> a[i];
    int x = 0;
    std::cout << "\nEnter x: ";
    std::cin >> x;
    //-------------------------------------------------------------------------
    // Найти такое i, -1<=i<n, что a[i]<=x<a[i+1]
    //-------------------------------------------------------------------------
    int i = RSearchEq(a, n, x);
    std::cout << "\nRSearchEq: i = " << i << std::endl;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Найти такое i, -1<=i<n, что a[i]<=x<a[i+1]
    //-------------------------------------------------------------------------
    i = RSearch(a, n, x);
    std::cout << "\nRSearch: i = " << i << std::endl;
    //-------------------------------------------------------------------------

    //-------------------------------------------------------------------------
    // Найти такое i, -1<=i<n, что a[i]<=x<a[i+1]
    //-------------------------------------------------------------------------
    i = RSearch_1(a, n, x);
    std::cout << "\nRSearch_1: i = " << i << std::endl;
    //-------------------------------------------------------------------------
    int j = ((i = -1) + (j = 0)) / 2;
    std::cout << "j = " << j << std::endl;

    delete[] a;
    system("pause");
    return 0;

}
